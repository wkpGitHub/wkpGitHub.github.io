<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>知识图谱</title>
  <script src="./quadtree.js"></script>
  <script src="d3.v5.js"></script>
  <script src="./c-force.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
  <style>
    #selectPath {
      cursor: crosshair;
    }

    * {
      padding: 0;
      margin: 0;
    }

    svg {
      background-color: #06101d;
      cursor: pointer;
      display: block;
    }

    .link-path {
      stroke: #fff;
      stroke-opacity: 0.4;
      fill: none;
      /* fill-opacity: 0.6; */
      stroke-dashoffset: 0;
    }

    .link-path:hover {
      stroke-opacity: 0.8;
    }

    .link-fade-in {
      stroke-dasharray: 5;
      animation: hover-animation 20s linear infinite;
    }

    .link-fade-out {
      stroke-dasharray: 5;
      animation: hover-animation 20s linear infinite reverse;
    }

    @keyframes hover-animation {
      to {
        stroke-dashoffset: 1000
      }
    }

    .animation-link {
      stroke-dasharray: 20, 10, 5, 5, 5, 10
    }

    .circle {
      stroke-width: 1px;
    }
   .out-circle{
      transform: rotate(180deg);
      
    }
    .inner-circle{
      transform: rotate(180deg) scale(0.7);
    }

    .node-text {
      font-size: 12px;
      /* fill: #fff; */
      /* fill-opacity: 0.8; */
      /* text-anchor: middle; */
      user-select: none;
    }

    .link-text {
      font-size: 12px;
      fill: #fff;
      fill-opacity: 0.3;
      text-anchor: middle;
      user-select: none;
    }
  </style>
</head>

<body>
  <svg width="1200" height="800">
    <defs>
      <radialGradient id="gradient" cx="50%" cy="50%" r="100%" fx="50%" fy="50%">
        <stop offset="0%" style="stop-color:blue;stop-opacity:0" />
        <stop offset="100%" style="stop-color:rgb(255,255,255);stop-opacity:1" />
      </radialGradient>
    </defs>
  </svg>
  <script>
    function getId () {
      return Math.random().toString(16).slice(2) + '-' + Math.random().toString(16).slice(6)
    }
    function getCos (source, target, r) {
      const x = Math.abs(source.x - target.x)
      const y = Math.abs(source.y - target.y)
      const z = Math.sqrt(x * x + y * y)
      const x0 = x * r / z || 0
      const y0 = y * r / z || 0
      let _x, _y
      if (source.x >= target.x) {
        _x = target.x + x0
      } else {
        _x = target.x - x0
      }
      if (source.y >= target.y) {
        _y = target.y + y0
      } else {
        _y = target.y - y0
      }
      return { _x, _y }
    }
    var w = window.innerWidth, h = window.innerHeight
    var simulation, links, nodes, nodeColor = '#00fff0', nodePath = 'M6.123233995736766e-16,-10A10,10,0,1,1,-6.123233995736766e-16,10A10,10,0,1,1,6.123233995736766e-16,-10Z'
    var svg = d3.select('svg').attr('width', w).attr('height', h).call(d3.zoom().on('zoom', function () {
      var transform = d3.event.transform; // {x,y,k} x坐标偏移量，y坐标偏移量, k缩放比例
      container.transform = transform
      container.attr("transform", "translate("
        + transform.x + "," + transform.y
        + ")scale(" + transform.k + ")");
    }))
    var container = svg.append('g')
    var gLinks = container.append('g').classed('links', true)
    var gTexts = container.append('g').classed('texts', true)
    var gNodes = container.append('g').classed('nodes', true)
    d3.select('svg').select('defs').append('marker').attr('id', 'arrow-marker').attr('markerWidth', 8).attr('markerHeight', 8).attr('refX', 16).attr('refY', 4)
      .attr('viewBox', '0 0 8 8').attr('fill', '#fff').attr('orient', 'auto').append('path').attr('d', 'M1,1L7,4L1,7z')
    d3.select('svg').select('defs').append('marker').attr('id', 'arrow-marker-end').attr('markerWidth', 8).attr('markerHeight', 8).attr('refX', 5).attr('refY', 4)
      .attr('viewBox', '0 0 8 8').attr('fill', '#fff').attr('orient', 'auto').append('path').attr('d', 'M1,1L7,4L1,7z')

    d3.json("./flare.json").then((data) => {
      // data.children.push(data)
      init(data)
    })
    function init (data) {
      var root = d3.hierarchy(data); // <-A
      nodes = root.descendants().map(item => {
        item.id = getId()
        return item
      }); // <-B
      links = root.links().map((item, index) => {
        item.index = index
        item.relation = item.target.data.name + '__' + item.source.data.name
        return item
      }); // <-C
      // updateNodes(nodes)
      simulation = d3.forceSimulation(nodes).alphaDecay(0.05)

      simulation.force("center", d3.forceCenter(w / 2, h / 2));
      simulation.force('manbody', d3.forceManyBody().strength(-100))
      simulation.force('link', d3.forceLink(links).distance(40))
      simulation.force("collide", d3.forceCollide(20))

      simulation.on('tick', () => {
        updateLinks(links)
        updateNodes(nodes)
      })
    }

    // 鼠标按下拖动画线
    function drawLine ({ parent, startx, starty, source }) {
      const { x, y, k } = container.transform || { x: 0, y: 0, k: 1 }
      var path = parent.insert('path', 'g').classed('link-path', true).attr('marker-end', 'url(#arrow-marker-end)').attr('transform', `scale(${k})`)
      var findNode
      function move (e) {
        const x0 = (e.x - x) / k
        const y0 = (e.y - y) / k
        const d = simulation.find(x0, y0, 18)
        if (d) {
          const { _x, _y } = getCos(source, d, 12)
          let dx = _x * k + x
          let dy = _y * k + y
          findNode = d
          path.attr('d', generateLinkPath({ x: startx / k, y: starty / k }, { x: dx / k, y: dy / k }))
        } else {
          findNode = null
          path.attr('d', generateLinkPath({ x: startx / k, y: starty / k }, { x: e.x / k, y: e.y / k }))
        }
      }
      function mouseup () {
        if (findNode) {
          links.push({ target: findNode, source, index: links.length })
          updateLinks(links)
          simulation.force('link', d3.forceLink(links).distance(30))
        }
        path.remove()
        window.removeEventListener('mousemove', move)
        window.removeEventListener('mouseup', mouseup)
      }
      window.addEventListener('mousemove', move)
      window.addEventListener('mouseup', mouseup)
    }

    function drawOutLine () {
      var arc = d3.arc().outerRadius(11).innerRadius(9).startAngle(0).endAngle(2 * Math.PI);
      return arc({ startAngle: 0, endAngle: 2 * Math.PI })
    }

    function bindDrag () {
      function started (d) {
        if (!d3.event.active) {
          simulation.alphaTarget(0.1).restart();//设置衰减系数，对节点位置移动过程的模拟，数值越高移动越快，数值范围[0，1]
        }
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged (d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
      }
      function ended (d) {
        if (!d3.event.active) {
          simulation.alphaTarget(0);
        }
        d.fx = null;
        d.fy = null;
      }
      return d3.drag().on("start", started).on("drag", dragged).on("end", ended)
    }

    function setR (d) {
      var _nodes = []
      links.forEach(item => {
        if (item.source.id === d.id) {
          _nodes.push(item.target)
        }
      })

      var _simulation = d3.forceSimulation(_nodes)
      _simulation.force("collide", d3.forceCollide(40))
      _simulation.on('tick', () => {
        updateNodes(nodes)
        updateLinks(links)
      }).on('end', () => {
        _simulation = null
      })
    }

    function setTextCoors (d) {
      const { x, y, nodeTextWidth } = d
      d.textCoors = {
        x0: x + 15,
        y0: y - 8,
        x1: x + 15 + nodeTextWidth,
        y1: y + 8
      }
    }

    function updateNodes (nodes) {
      const { innerFill, innerStroke, outerFill, outerStroke } = set16ToRgb(nodeColor)
      var updateSelections = gNodes.selectAll('g.g-circle').data(nodes)
      var enterSelections = updateSelections.enter().append('g').classed('g-circle', true)
      enterSelections.append('path').attr('d', nodePath).classed('out-circle', true)
      enterSelections.append('path').attr('d', nodePath).classed('inner-circle', true)
      enterSelections.append('text').classed('node-text', true).attr('dx', 15).attr('dy', 4).text(d => d.data.name)

      var mergeSelections = updateSelections.merge(enterSelections).attr('opacity', d => d.hidden ? '0.2' : '1').attr('transform', d => `translate(${d.x},${d.y})`)
        .on('click', function (d) {

          const that = d3.select(this)
          if (this.hasAttribute('selected')) return false
          this.setAttribute('selected', true)
          d3.select(this).append('path').attr('id', 'selectPath').attr('d', drawOutLine()).attr('fill', '#fff').attr('fill-opacity', 0.8).on('mousedown', function () {
            const e = d3.event
            e.stopPropagation()
            const transform = container.transform || { x: 0, y: 0, k: 1 }
            let x = d.x * transform.k + transform.x
            let y = d.y * transform.k + transform.y
            drawLine({ parent: d3.select('svg'), startx: x, starty: y, source: d })
          })
          setR(d)
        })
        // .on('mousedown', function (d) {
        //   d3.event.stopPropagation()

        // })
        .on('mouseover', function (d) {
          links.forEach(item => {
            item.source.hidden = true
            item.target.hidden = true
            if (item.source.id === d.id) {
              item.current = true
            }
            if (item.target.id === d.id) {
              item.current = true
            }
          })
          links.forEach(item => {
            if (item.current) {
              item.source.hidden = false
              item.target.hidden = false
            }
          })

          updateNodes(nodes)
          updateLinks(links)
        })
        .on('mouseout', function (d) {
          links.forEach(item => {
            delete item.current
            delete item.source.hidden
            delete item.target.hidden
          })
          updateNodes(nodes)
          updateLinks(links)
        })
        .call(bindDrag())

      mergeSelections.select('.out-circle').attr('fill', outerFill).attr('d', nodePath).attr('stroke', outerStroke)
      mergeSelections.select('.inner-circle').attr('fill', innerFill).attr('d', nodePath).attr('stroke', innerStroke)
      mergeSelections.select('.node-text').attr('fill', innerFill).attr('width', function (d) {
        d.nodeTextWidth = this.getComputedTextLength()
        setTextCoors(d)
      })

      
      updateOpc(nodes, mergeSelections)

      updateSelections.exit().remove()
    }

    function generateLinkPath (target, source) {
      var path = d3.path();
      path.moveTo(target.x, target.y);
      path.quadraticCurveTo((target.x + source.x) / 2, target.y, source.x, source.y);
      // path.lineTo(source.x, source.y)
      return path.toString();
    }

    function hightLight (d) {
      const cb = () => {
        createFeiLine({
          defs: d3.select('svg').select('defs'),
          container: gLinks,
          pathSelection: d3.select(this),
          maskRadius: 10,
          stroke: nodeColor,
          strokeWidth: 1,
          duration: 2000
        })
      }

      d.feiTimer = setTimeout(() => {
        if (d.current) {
          cb()
          d.feiInterval = setInterval(cb, 2000)
        }
      }, 500)
    }

    function updateLinks (links) {
      // updateTexts(links)

      var updateLinks = gLinks.selectAll('path').data(links)
      var enterLinks = updateLinks.enter().append('path').classed('link-path', true)
      // enterLinks.each(function(d, index) {
      //   const getMiddlePoint = () => {
      //     const { source, target } = d
      //     const pathline = d3.select(this).node()
      //     const len = pathline.getTotalLength()
      //     const { x, y } = pathline.getPointAtLength(0.5 * len)
      //     d.relationPointer = { x, y }
      //     d.relationRotate = Math.atan((target.y - source.y) / (target.x - source.x)) * 360 / (2 * Math.PI)
      //   }
      //   d.updateRelationPath = throttle_debounce(getMiddlePoint, 10)
      // })
      updateLinks.merge(enterLinks).attr('d', function (d) {
        const { source, target } = d
        const { _x, _y } = getCos(source, target, 12)
        return generateLinkPath(source, { x: _x, y: _y })
      }).attr('marker-end', 'url(#arrow-marker-end)').attr('opacity', function (d) {
        clearInterval(d.feiInterval)
        clearTimeout(d.feiTimer)
        hightLight.bind(this)(d)
        // d.updateRelationPath()

        return d.current ? 1 : 0.2
      })

      updateLinks.exit().remove()
    }

    function updateTexts (links) {
      var updateTexts = gTexts.selectAll('g.gtext').data(links)
      var enterTexts = updateTexts.enter().append('g').classed('gtext', true)
      enterTexts.append('text').classed('link-text', true).text(d => d.relation).attr('dy', 5).attr('width', function (d) {
        d.textWidth = this.getComputedTextLength() + 8
      })
      enterTexts.insert('rect', 'text').attr('width', d => d.textWidth).attr('height', 20).attr('fill', '#06101d').attr('x', d => -d.textWidth / 2).attr('y', -10)
      updateTexts.merge(enterTexts).attr('transform', d => {
        const { relationPointer, relationRotate = 0 } = d

        return relationPointer ? `translate(${relationPointer.x},${relationPointer.y}) rotate(${relationRotate})` : ''
      })

      updateTexts.exit().remove()
    }

    d3.select('svg').node().addEventListener('mousedown', (e) => {
      var selectPath = d3.select('#selectPath')
      if (e.target.parentNode.hasAttribute('selected')) return false
      if (selectPath) {
        selectPath.node()?.parentNode.removeAttribute('selected')
        selectPath.remove()
      }
    }, true)

    const gui = new dat.GUI();
    gui.addColor({ '选择颜色': '#00fff0' }, '选择颜色').onChange(v => {
      nodeColor = v
      updateNodes(nodes)
    })
    gui.add({ '选择图形': 'M6.123233995736766e-16,-10A10,10,0,1,1,-6.123233995736766e-16,10A10,10,0,1,1,6.123233995736766e-16,-10Z' }, '选择图形', {
      '圆形': 'M6.123233995736766e-16,-10A10,10,0,1,1,-6.123233995736766e-16,10A10,10,0,1,1,6.123233995736766e-16,-10Z', 
      '五角星': 'M 0,10 L3,4 L9,3.8 L4.8,-1.3 L6,-8 L0,-5 L-6,-8 L-4.8,-1.3 L-9,3.8 L-3,4Z'
    }).onChange(v => {
      nodePath = v
      updateNodes(nodes)
    })

  </script>
</body>

</html>